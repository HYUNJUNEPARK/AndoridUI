1. 안드로이드 4대 컴포넌트
a. 액티비티 : 화면 UI 담당
b. 브로드캐스트 리시버 : 시스템 또는 사용자가 발생하는 메세지를 수준
c. 서비스 : 백그라운드 코드 처리를 담당
d. 콘텐트 프로바이더 : 앱끼리 데이터를 공유하기 위한 컴포넌트

액티비티 백스택 : 액티비티 또는 화면 컴포넌트를 담는 안드로이드 저장 공간으로 스택으로 저장. 사용자는 가장 위에 있는 액티비티를 보게됨

inflate : XML 로 작성된 레이아웃 파일을 코드에서 사용할 수 있도록 변환해주는 메서드
val binding by lazy { ActivityMainBinding.inflate(layoutInflater) }

cf 컴포넌트를 사용하기 위한 도구
인텐트 : a,b,c 컴포넌트를 실행하기 위해 시스템에 전달되는 도구
콘텐트 리졸버 : 콘텐트 프로바이더가 제공하는 데이터를 사용하기 위한 도구

init : 파라미터와 반환값이 없는 함수로 생성자를 통해 인스턴스가 호출될 때 호출되는 함수
________________________________________________________________________________
2. 컨텍스트(Context)
시스템을 사용하기 위한 프로퍼티와 메서드가 담겨있는 클래스
컴포넌트 실행 시 생성되고, 생성된 컴포넌트가 갖고 있는 메서드를 호출해서 사용
액티비티는 컨텍스트를 상속받아 구현됨 

UI 구성요소를 사용하기 위해서는 컨텍스트가 필요한데 액티비티 이외의 다른 클래스에는 컨텍스트가 없기 떄문에
액티비티로부터 미리 받아서 저장해두고 사용하기도 하는데, 이는 단계가 너무 복잡함
이를 해결하기 위해 '모든 뷰는 컨텍스트를 갖고 있다' 는 점을 이용할 수 있는데, 해당 클래스에서 뷰를 사용한다면 모든 종류의 뷰가 컨텍스트를 갖고 있고,
binding.root 또한 뷰이기 때문에 binding.root.context 의 형태로 컨택스트를 갖고 올 수 있음 
Toast.makeText(binding.root.context, ... ).show()
________________________________________________________________________________
3. 인텐트(Intent)
인텐트를 생성하고 startActivity() 메서드에 담아서 호출하면 액티비티 매니저에 전달됨
액티비티 매니저가 인텐트를 분석해 타킷 액티비티를 실행시킴
타킷 액티비티에서는 전달받은 인텐트에 데이터가 있다면 꺼내서 사용 가능
val intent = Intent(this@Context, SubActivity::class.java)
startActivity(intent)
startActivityForResult() //deprecated 되었기 때문에 ActivityResultLauncher 사용 -> 1_Intent 에 반영

번들(bundle)
인텐트 내부에 존재하는 데이터 저장 공간
인텐트에 값을 입력할 때는 key : value 조합으로 번들에 넣고 //intent.putExtra("key", "value")
꺼낼 때는 key 로 꺼냄 //intent.getStringExtra("key")
________________________________________________________________________________
4. 태스크
애플리케이션에서 실행되는 프로세스를 관리하는 작업 단위.
앱당 하나의 프로세스를 생성하고 액티비티를 처리하는데 태스크는 서로 다른 프로세스(다른 앱)간 액티비티를 공유할 수 있음.
이렇게 묶인 서로 다른 프로세스의 액티비티를 처리하는 작업단위가 태스크
ex) 카메라 앱과 갤러리 앱

태스크를 관리하는 방법
1) manifest 의 설정으로 관리 ex) anroid:launchMode="singleInstance"
2) startActivity() 메서드에 전달하는 intent 의 플래그 값으로 관리
________________________________________________________________________________
5. 리사이클러뷰
a. onCreateViewHolder
아이템 레이아웃 생성. 아이템 레이아웃을 바인딩한 후 '뷰홀더' 에 넘겨줌
스마트폰 화면에 보이는 목록 갯수만큼 안드로이드 시스템이 이 메서드 호출.
b. getItemCount
리사이클러뷰에서 사용할 데이터의 총 개수를 리턴
c. onBindViewHolder
생성된 뷰홀더를 화면에 '보여주는' 메서드
화면에 보이는 아이템 레이아웃의 인덱스 데이터(position)를 갖고 있음
인덱스 데이터 파라미터를 홀더 클래스 내부 함수로 전달할 수 있음
d. Holder
class Holder(바인딩) : RecyclerView.ViewHolder(바인딩.root)
뷰홀더는 현재 화면에 보여지는 개수만큼만 생성되고 스크롤이 이동하면 화면에 보이지 않는 목록을 담은 홀더는 아래로 이동해 재사용 됨
onBindViewHolder() 메서드로 부터 인덱스 파라미터를 받아 처리하는 메서드를 만들 수 있음
목록에서 아이템 1개가 클릭 되었을 때 처리 방법 : 홀더가 갖고 있는 아이템 바인딩에 클릭리스너를 달아 처리
________________________________________________________________________________
6. 프래그먼트
프래그먼트 생성 [New]-[Fragment]-[Fragment(Blank)]
안드로이드 스튜디오 4.2 이후 버전부터는 앱 수준 build.gradle 파일의 minSdkVersion 설정이 최소 16이 되지않는다면 이 방법으로 프래그먼트 생성 불가

프래그먼트는 하나의 레이아웃에 한 층씩 쌓이는 형태라 기본 배경색을 성정하지 않으면 화면이 중첩됨
쌓여진 프래그먼트들의 버튼이 중첩되어있다면 동시에 두개가 눌릴 수 있음 -> 최상단 레이아웃(ex. ConstraintLayout) 속성에 android:clickable="true" 를 줌

액티비티를 분할해 독립적인 코드로 구성한 것으로 액티비티의 일부로 사용됨
2개 이상의 화면을 빠르게 이동한다든지 탭으로 구성된 화면의 자연스러운 움직임을 구현할 때 사용
프래그먼트는 기본적으로 하나의 뷰로 작동하기 때문에 액티비티 안에 뷰를 삽입할 수 있는 레이아웃을 준비해둬야함(fragment/FrameLayout)
a. Common - <fragment> : 화면 전환 없이 프래그먼트 하나만 화면에 표시 할 때
b. Layouts - FrameLayout : 화면 전환이 필요할 때 

액티비티와는 별개의 생명주기를 갖고 있어 상황에 따라 생명주기 관련 코드를 액티비티와 프래그먼트 양쪽에 작성해야함

트랜잭션 : 서로 연관되어 있는 작업을 할 때 중간에 하나라도 잘못되면 모든 동작을 복구하는 하나의 작업 단위
beginTransaction -> add fragment -> commit transaction 순으로 처리됨
supportFragmentManager : 액티비티가 갖고 있는 프래그먼트 매니저
add(액티비티에서 프래그먼트가 삽입될 레이아웃 id, 삽입할 프래그먼트)

arguments : 프레그먼트의 기본 프로퍼티로 Bundle() 객체를 전달하면 생성된 프래그먼트에서 argument 를 꺼낼 수 있음
listFragment.arguments = bundle

프래그먼트 리스너 : 프래그먼트 간 통신을 위해 fragment 버전 1.3.x 부터 제공되는 기능
https://developer.android.com/jetpack/androidx/releases/fragment#kts 에서 최신 버전 확인할 수 있음
프래그먼트에 onViewCreated() 를 오버라이드한 후 블럭 내부에 코드 작성
setFragmentResult("requestKey", bundle) : 데이터를 보내는 프래그먼트에서 사용
/*
   bundleOf("key" to "value") 로 쉽게 bundle 객체를 만들 수 있음
   bundle 에는 valueKey 라는 인식표(키)에 데이터 DataInBundle1 가 담겨있음
   setFragmentResult("requestKey", bundle) : 데이터를 보내는 프래그먼트에서 사용
*/
setFragmentResultListener("requestKey") : 데이터를 받는 프래그먼트에서 사용
________________________________________________________________________________
7. 뷰
뷰 : 화면을 구성하는 최소 단위의 컴포넌트. UI 편집기의 팔레트에 있는 모든 것들이 뷰
뷰그룹 : 레이아웃
위젯과 레이아웃의 최상위 클래스인 View 는 화면에 그림을 그리기 위한 onDraw() 메서드를 갖고 있음
View 는 Context 를 생성자에서 입력받아야 하므로 View 를 상속받는 클래스에도 Context 를 입력 받는 생성자가 하나 꼭 있어야함
View 클래스를 상속받은 후에 onDraw() 메서드로 전달되는 Canvas 를 사용하면 원하는 그림을 그릴 수 있음
-onDraw(canvas: Canvas?)
오버라이딩해서 사용하며 내부에 코드를 작성해 UI 에 도형을 그림
-Canvas 클래스
Canvas 는 그리기 도구로 그림판과 함께 그림을 그리기 위해 draw 로 시작하는 메서드가 제공됨
ex) drawText, drawCircle, drawRect, drawRoundRect 등
drawText(text, x좌표, y좌표, 색상 정보)
drawText 를 할 때 좌표의 기준이 문자열의 좌측 하단이기 때문에 y 좌표 속성이 없다면 텍스트의 아래 부분만 짤려서 나옴

커스템 위젯 : 회사 내부에서 기본 위젯을 상속 받아 앞에 접두어를 붙혀 커스텀 위젯으로 사용 ex) KakaoTextView
CustomWidget : yyyyMMdd 로 된 값을 입력하면 yyyy-MM-dd 로 연월일 사이에 자동으로 - 를 넣어주는 위젯
3가지 단계를 거침
1) attr.xml 파일 생성 (커스텀 위젯의 속성 정보가 담겨있음)
   [res] - [values] - attr.xml
   레이아웃 파일에서 태그 속성의 접두사가 android 가 아닌 userCustom 으로 정의된 새로운 속성 값을 사용할 수 있음
2) CustomWidget 클래스 생성
   커스텀을 하기 위한 위젯 클래스를 상속받아 클래스를 생성하고 1) 에서 새롭게 정의한 속성을 처리하는 코드 작성
   * 버전 호환성을 위해 기본 위젯 TextView 가 아니라 AppCompatTextView 를 상속받는다.
   * 항상 생성자 3개를 모두 작성해 두는 것이 좋음 //우클릭 -> Generate -> Secondary Constructor
3) 레이아웃에 태그 적용
   palette 에 project 가 생성되는 데 거기에 생성한 CustomWidget 이 있음
   * project 가 보이지 않을 때는 안드로이드 스튜디오를 재시작함

________________________________________________________________________________
8. 뷰페이저/탭레이아웃
뷰페이저 : 스와이프로 화면을 전환할 수 있도록 제공되는 컨테이너. 한 화면에 하나의 아이템만 보이는 리사이클러뷰 개념과 유사
페이저어댑터 : 뷰페이저에서 보일 화면들을 연결하는 구조
탭레이아웃 : 탭 메뉴 구성을 위한 레이아웃
-> 2개의 컨테이너를 코드로 연결해서 UI를 구성할 수 있음

뷰페이저 생성
Palette -> Containers -> ViewPager2 로 컨테이너 추가
안드로이드 스튜디오 4 버전부터 ViewPager 에서 ViewPager2 로 변경됨
ViewPager2 에서는 TabLayoutMediator 로 탭레이아웃과 뷰페이저를 연결할 수 있음

탭레이아웃 생성
Palette -> Containers -> TabLayout 으로 컨테이너 추가
________________________________________________________________________________
